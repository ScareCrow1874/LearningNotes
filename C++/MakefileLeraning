Software development tutorial:

Makefile for C++

#Comment;
#Makefile is used for speeding up compliation. Nothing else good;

CXX = g++ #variable on the left, command on the right
CXXFLAGS = -W -Wall

target: prerequicites ...
<tab>recipe
	 ...
	 ...

#target is usually the name of a file that is generated by a program (executable or object files); it can also be the name of an action to carry out such as 'clean'

#prerequisite is a file that is used as input to create the target;
#recipe is an action that 'make' carries out.

------------------------------
Terminal compile:
	g++ -c file.cpp // -c = compile
	g++ file1.o file2.o -o program.exe // -o = link
------------------------------

Compiling a C++ program:
	1st step, convert the original file to the object file (.o). This action is called compile!
	2nd step, merge a bunch of object files to executable files. This action is called link!

While compiling, the compiler wants your code to have good syntax and correct declaration of variables and functions, which should be done in the header file.

It is said that every original file (.cpp) should match one object file (.o)

If there are too many object files generated, it is good to make library file (static library) (.lib on Windows, .a on Unix)
The library is linked to the object codes, so it is part of the final execution file.

------------------------------
'make' needs a Makefile file to execute
Here is a cool example:
In a project, there are 8 .c files and 3 .h files. Write a Makefile to make rules for compliling:
	Rule 1: If the project is not compiled, all .c files should be compiled and linked;
	Rule 2: If some .c files are changed, only compile those changed files;
	Rule 3: If one or more head files are changed, then compile those .c files that included the .h files, and link them.
------------------------------
Name the makefile "makefile" or "Makefile" and then enter the 'make' command in the directory;

How make works:
default make:
	It finds the file with name "Makefile" or "makefile"
	If it finds it, it will look for the first target file, and regard it as the ultimate target file;
	If that first one does not eist, or the files in the prerequisite has modified time later than the target, then 'make' will execute the commands followed to generate the first target file;
-------------------------------
Command "clean" will clean all the target files for compliation next time;
Command "all" will build the prerequisites sequentially
e.g. :
	all: hello.out world.out

	hello.out : hello.cpp functions.hpp
		g++ -o hello.out hello.cpp
	world.out : world.cpp functions.hpp
		g++ -o world.out world.cpp

$(MAKE): call make command
-------------------------------
Static Library
	create a static library:
	-> g++ -o lib.o -c lib.cc #Create the object file (you may have other methods to do this)
	-> ar rcs lib.a lib.o #create the library
	link the library to the executable
	-> g++ main.cpp -L. lib.a #compile and link

Dynamic Library (shared)
	Create a dynamic library:
	-> g++ -fPIC -shared sourceFiles -o libNAME.so
	Link the Dynamic library:
	-> g++ target -L. -lNAME
	-> export LD_LIBRARY_PATH = "Path of the library";
	"./" -- current directory
	"../" -- previous directory
	export: change environment variables

Repository:
	For "Version Control System" (VCS)
	Stores the files themselves
	Stores revision information: changes to each file, and comments on the changes;

-------------------------------
